<!DOCTYPE html>
<html lang="ru">

<head>
	<title>Введение во Frontend</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="icon" type="image/png" href="/lib/favicon.png" />
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="/lib/shower/themes/styles/screen-4x3.css">
	<link rel="stylesheet" href="/lib/slides.css">

</head>

<body class="shower list">

	<header class="caption">
		<h1>Full-stack разработка</h1>
		<p>МФТИ</p>
	</header>

	<section class="slide first">
		<h2 class="shout">Семинар №4<br />
			<small>Слайды доступны по ссылке<br />
				<a href="https://mfti-frontend.herokuapp.com/">mfti-frontend.herokuapp.com</a>
			</small>
		</h2>
	</section>

    <section class="slide">
        <h2 class="shout">React</h2>
    </section>

    <section class="slide">
        <h2>SPA</h2>
        <p class="medium-content">
        <blockquote>
            <strong>Single page application</strong> &mdash; веб-сайт, использующий единственный
            HTML-документ как оболочку для всех веб-страниц и организующий взаимодействие с пользователем через динамически
            подгружаемые HTML, CSS, JavaScript
        </blockquote>
        </p>

        <p class="small-content">
        <ul lang="ru">
            <li>React</li>
            <li>Angular</li>
            <li>Vue</li>
        </ul>
        </p>
    </section>

    <section class="slide">
        <h2>Что такое React?</h2>
        <p class="medium-content">
        <blockquote>
            <strong>React</strong> &mdash; JavaScript-библиотека для создания пользовательских интерфейсов
        </blockquote>
        </p>

        <p class="small-content">
        <ul lang="ru">
            <li>Создана и поддерживается facebook-ом</li>
            <li>Основана на компонентах, представляющих собой функции от входных переменных и состояния</li>
            <li>Использует Virtual Dom для оптимизации перерисовки интерфейса</li>
        </ul>
        </p>

        <a href="https://ru.reactjs.org" target="_blank">ru.reactjs.org</a>
    </section>

    <section class="slide">
        <h2>React-компонент</h2>
        <p class="medium-content"></p>
        <pre class="hljs js">
					<code>import React, {Component} from 'react';</code>
					<code>import {render} from 'react-dom';</code>
					<code> </code>
					<code>class App extends Component {</code>
					<code>	render() {</code>
					<code>		return (</code>
					<code>			&lt;h1&gt;Hello World&lt;/h1&gt;</code>
					<code>		);</code>
					<code>	}</code>
					<code>}</code>

					<code>render(&lt;App &gt;, document.getElementById('root'));</li></code>
					<code></code>
					</pre>
    </section>

    <section class="slide">
        <h2>Функциональные компоненты</h2>
        <p class="medium-content"></p>
        <pre class="hljs js">
				<code>import React from 'react';</code>
				<code> </code>
				<code>const Avatar = (props) => &lt;img src={props.src} /&gt;</code>
				<code> </code>
				<code>const Header = () => (</code>
				<code>	&lt;header&gt;</code>
				<code>		&lt;Avatar src={'http://bestimage.com/1.png'} /&gt;</code>
				<code>		Sergey Barsukov</code>
				<code>	&lt;/header&gt;</code>
				<code>)</code>

				<code>render(&lt;App /&gt;, document.getElementById('root'));</li></code>
				<code></code>
				</pre>
    </section>

    <section class="slide">
        <h2>JSX</h2>
        <blockquote>
            <strong>JSX</strong> &mdash; специальный синтаксис для описания React-компонентов. После компиляции каждое
            JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
        </blockquote>

        <pre class="hljs js">
			<code> </code>
			<code>const element = (</code>
			<code>	&lt;h1 className="greeting"/&gt;</code>
			<code>		Привет, мир!</code>
			<code>	&lt;/h1&gt;</code>
			<code>);</code>
			<code> </code>
			<code> </code>
		</pre>
        <a href="https://babeljs.io/repl" target="_blank">https://babeljs.io/repl</a> &mdash; попробовать можно тут

    </section>


    <section class="slide">
        <h2>JSX</h2>
        <blockquote>
            <strong>JSX</strong> &mdash; специальный синтаксис для описания React-компонентов. После компиляции каждое
            JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
        </blockquote>
        <pre class="hljs js">
					<code> </code>
					<code>const element = React.createElement(</code>
					<code>	'h1',</code>
  				<code>	{className: 'greeting'},</code>
  				<code>	'Привет, мир!'</code>
					<code>);</code>
					<code> </code>
					<code> </code>
				</pre>
        <a href="https://babeljs.io/repl" target="_blank">https://babeljs.io/repl</a> &mdash; попробовать можно тут

    </section>

    <section class="slide">
        <h2>JSX</h2>
        <blockquote>
            <strong>JSX</strong> &mdash; специальный синтаксис для описания React-компонентов. После компиляции каждое
            JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
        </blockquote>

        <pre class="hljs js">
				<code>// Примечание: этот код несколько упрощён.</code>
				<code>const element = {</code>
				<code>	type: 'h1',</code>
				<code>	props: {</code>
				<code>		className: 'greeting',</code>
				<code>		children: 'Привет, мир!'</code>
				<code>	}</code>
				<code>};</code>
				</pre>
        <a href="https://babeljs.io/repl" target="_blank">https://babeljs.io/repl</a> &mdash; попробовать можно тут

    </section>


    <section class="slide">
        <h2>Virtual DOM</h2>
        <p class="medium-content"></p>
        <ul>
            <li>Вместо того, чтобы взаимодействовать с DOM напрямую, мы работаем с его <mark>легковесной копией</mark></li>
            <li>Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к
                реальному DOM</li>
            <li>При этом происходит сравнение DOM-дерева с его виртуальной копией, <mark>определяется разница и запускается
                перерисовка того, что было изменено</mark></li>
        </ul>
    </section>

    <section class="slide">
        <h2>Virtual DOM</h2>
        <div style="position:relative;width: 100%; height: 75%;">
            <img class="place" src="dom-vdom.png"
                 style="transform-origin: center;transform: translate(-48.5%,-50%) scale(0.7);">
        </div>
    </section>


    <section class="slide">
        <h2 class="shout">Жизненный цикл</h2>
    </section>

    <section class="slide">
        <h2>Внутреннее состояние</h2>
        <p>Объект state описывает внутреннее состояние компонента, он похож на props за тем исключением, что состояние
            определяется внутри компонента и доступно только из компонента. Если props представляет входные данные, которые
            передаются в компонент извне, то состояние хранит такие объекты, которые создаются в компоненте и полностью
            зависят от компонента.
        </p>
        <ul>
            <li><code>this.setState()</code> &mdash; асинхронная функция, в которую передается объект с новыми значениями
                состояния</li>
            <!-- <li><code>this.setState()</code> &mdash; асинхронная функция, в которую передается объект с новыми значениями
                состояния</li> -->
        </ul>
    </section>

    <section class="slide">
        <h2>Методы жизненного цикла</h2>
        <p>React предоставляет разработчикам множество методов и «хуков», которые вызываются во время жизненного цикла
            компонента, они позволяют нам обновлять UI и состояние приложения.
        </p>
        <ul>
            <li><code>componentDidMount()</code></li>
            <li><code>componentDidUpdate(prevProps, prevState)</code></li>
            <li><code>componentWillUnmount()</code></li>
            <li><code>shouldComponentUpdate(nextProps, nextState)</code></li>
            <li><code>static getDerivedStateFromProps(props, state)</code></li>
        </ul>
    </section>

    <section class="slide">
        <h2>Методы жизненного цикла</h2>
        <div style="position:relative;width: 100%; height: 100%;">
            <img class="place" src="lifecycle.png"
                style="transform-origin: center;transform: translate(-50%,-55%) scale(0.43);">
        </div>
    </section>

    <section class="slide">
        <h2>componentDidMount()</h2>
        </p>
        <ul>
            <mark>ДЕЛАЙТЕ:</mark>
            <li>Выполняйте сайд-эффекты (Запросы к серверу и т.д.)</li>
        </ul>
    </section>

    <section class="slide">
        <h2>componentDidUpdate(prevProps, prevState)</h2>
        </p>
        <ul>
            <mark>ДЕЛАЙТЕ:</mark>
            <li>Выполняйте сайд-эффекты (Запросы к серверу и т.д.)</li>
            <br>
            <mark>НЕ ДЕЛАЙТЕ:</mark>
            <li>Не вызывайте this.setState т.к. это может вызвать циклическую перерисовку.</li>
        </ul>
    </section>

    <section class="slide">
        <h2>componentWillUnmount()</h2>
        </p>
        <ul>
            <mark>ДЕЛАЙТЕ:</mark>
            <li>Удаляйте таймеры и слушателей (listeners) созданных во время жизни компонента.</li>
            <br>
            <mark>НЕ ДЕЛАЙТЕ:</mark>
            <li>Не вызывайте this.setState, не стартуйте новых слушателей или таймеры.</li>
        </ul>
    </section>

    <section class="slide">
        <h2>shouldComponentUpdate(nextProps, nextState)</h2>
        </p>
        <ul>
            <mark>ДЕЛАЙТЕ:</mark>
            <li>Используйте для оптимизации производительности компонента</li>
            <br>
            <mark>НЕ ДЕЛАЙТЕ:</mark>
            <li>Не выполняйте никаких сайд-эффектов (Вызовы AJAX и т.д.)</li>
            <li>Не вызывайте this.setState</li>
        </ul>
    </section>

    <section class="slide">
        <h2>static getDerivedStateFromProps(props, state)</h2>
        </p>
        <ul>
            <mark>ДЕЛАЙТЕ:</mark>
            <li>Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах.</li>
    </section>

    <section class="slide">
        <h2 class="shout">React Router</h2>
    </section>

<!--	<section class="slide">-->
<!--		<h2 class="shout">Redux</h2>-->
<!--	</section>-->

<!--	<section class="slide">-->
<!--		<h2>Редакс</h2>-->
<!--		<div style="position:relative;width: 100%; height: 75%;">-->
<!--			<img class="place" src="redux0.png"-->
<!--				style="transform-origin: center;transform: translate(-50.45%,-51%) scale(1.9);">-->
<!--		</div>-->
<!--	</section>-->

<!--	<section class="slide">-->
<!--		<h2>Редакс с запросами</h2>-->
<!--		<div style="position:relative;width: 100%; height: 75%;">-->
<!--			<img class="place" src="redux.png"-->
<!--				style="transform-origin: center;transform: translate(-50.45%,-51%) scale(1.5);">-->
<!--		</div>-->
<!--	</section>-->

	<section class="slide">
		<h2 class="shout">Всем спасибо!</h2>
	</section>

	<div class="progress"></div>
	<script src="/lib/shower/shower.min.js"></script>
	<script src="/lib/hljs/highlight.pack.js"></script>
	<script>
		hljs.initHighlightingOnLoad();
	</script>
</body>

</html>
