<!DOCTYPE html>
<html lang="ru">

<head>
	<title>Введение во Frontend</title>
	<meta charset="utf-8">
	<meta http-equiv="x-ua-compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<link rel="icon" type="image/png" href="/lib/favicon.png" />
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<link rel="stylesheet" href="/lib/shower/themes/styles/screen-4x3.css">
	<link rel="stylesheet" href="/lib/slides.css">

</head>

<body class="shower list">

	<header class="caption">
		<h1>Full-stack разработка</h1>
		<p>МФТИ</p>
	</header>

	<section class="slide first">
		<h2 class="shout">Семинар №3<br />
			<small>Слайды доступны по ссылке<br />
				<a href="https://mfti-frontend.herokuapp.com/">mfti-frontend.herokuapp.com</a>
			</small>
		</h2>
	</section>

	<section class="slide">
		<h2 class="shout">Работа с сетью в JavaScript</h2>
	</section>

	<section class="slide">
		<h2>Протокол HTTP</h2>
		<blockquote>
			<p class="small-content"><b>HTTP (HyperText Transfer Protocol — «протокол передачи гипертекста»)</b> &mdash;
				протокол прикладного уровня передачи данных (изначально &mdash; в виде гипертекстовых документов в формате
				«HTML»), в настоящий момент используется для передачи произвольных данных</p>
		</blockquote>
	</section>

	<section class="slide">
		<h2>HTTP запрос</h2>
		<p class="medium-content"></p>
		<pre class="hljs http">
			<code>// METHOD URI HTTP/VERSION <= стартовая строка</code>
			<code>GET /slides.css HTTP/1.1</code>
			<code>Host: mfti-frontend.herokuapp.com/</code>
			<code>Content-Type: text/css; charset=utf-8</code>
			<code>другие заголовки...</code>
			<code> </code>
			<code>        тело запроса (опционально)</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>HTTP ответ</h2>
		<p class="medium-content"></p>
		<pre class="hljs http">
			<code>// HTTP/VERSION STATUS_CODE REASON_PHRASE <= стартовая строка</code>
			<code>HTTP/1.0 200 OK</code>
			<code>Host: mfti-frontend.herokuapp.com/</code>
			<code>Content-Type: text/css; charset=utf-8</code>
			<code>другие заголовки...</code>
			<code> </code>
			<code>        тело ответа (опционально)</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Работа с XMLHttpRequest</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>// 1. Создаём новый объект XMLHttpRequest</code>
			<code>const xhr = new XMLHttpRequest();</code>
			<code>// 2. Конфигурируем его: GET-запрос на URL '/lib/slides.css'</code>
			<code>xhr.open('GET', '/slides.css', <mark>false</mark>);</code>
			<code> </code>
			<code>// 3. Отсылаем запрос</code>
			<code>xhr.send();</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Работа с XMLHttpRequest</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>// 4. Если код ответа сервера не 200, то это ошибка</code>
			<code>console.log(`Ответ от сервера: ${xhr.status} ${xhr.statusText}`);</code>
			<code>if (xhr.status === 200) {</code>
			<code>    console.log(xhr.responseText);</code>
			<code>} else {</code>
			<code>    console.error('Ошибка!')</code>
			<code>}</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Пример POST-запроса</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('POST', '/post', <mark>false</mark>);</code>
			<code> </code>
			<code>// Выставляем заголовок</code>
			<code>xhr.<mark>setRequestHeader</mark>('Content-Type', 'text/plain; charset=utf-8');</code>
			<code>xhr.send('Request payload');</code>
			<code>// ждём ответа</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Отправка json в теле запроса</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('POST', '/post', <mark>false</mark>);</code>
			<code> </code>
			<code>// Выставляем заголовок</code>
			<code>xhr.<mark>setRequestHeader</mark>('Content-Type', 'application/json; charset=utf-8');</code>
			<code>xhr.send(JSON.stringify({name: 'Alex'});</code>
			<code>// ждём ответа</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Отправка бинарных данных в <br>теле запроса</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('POST', '/post', <mark>false</mark>);</code>
			<code> </code>
			<code>const binary = new Uint8Array(1024 * 1024); // 1 MB данных</code>
			<code>const blob = new Blob([binary], {type: 'application/octet-stream'});</code>
			<code>xhr.send(blob);</code>
			<code>// ждём ответа</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Отправка файлов в теле запроса</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('POST', '/post', <mark>false</mark>);</code>
			<code> </code>
			<code>const fileInput = document.querySelector('input[type=file]');</code>
			<code>const file = fileInput.files[0].file;</code>
			<code>const formdata = new FormData();</code>
			<code>formdata.append('file', file);</code>
			<code>xhr.send(formdata);</code>
			<code>// ждём ответа</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2><mark>Асинхронные</mark> запросы</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.open('GET', '/lib/slides.css', <mark>true</mark>);</code>
			<code> </code>
			<code>xhr.<mark>onreadystatechange</mark> = function() {</code>
			<code>    if (xhr.<mark>readyState</mark> !== 4) return;</code>
			<code>    console.log(`Ответ от сервера: ${xhr.status} ${xhr.statusText}`);</code>
			<code>    console.log(xhr.responseText);</code>
			<code>}</code>
			<code>xhr.send();</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Событие <code>readystatechange</code></h2>
		<p class="medium-content"></p>
		<pre class="hljs c">
			<code>// Значения <mark>readyState</mark></code>
			<code>const unsigned short UNSENT = 0; // начальное состояние</code>
			<code>const unsigned short OPENED = 1; // вызван open</code>
			<code>const unsigned short HEADERS_RECEIVED = 2; // получены заголовки</code>
			<code>const unsigned short LOADING = 3; // загружается тело</code>
			<code>const unsigned short DONE = 4; // запрос завершён</code>
			<code> </code>
		</pre>
	</section>

	<section class="slide">
		<h2>Другие события</h2>
		<p class="medium-content"></p>
		<ul lang="ru">
			<li><code>loadstart</code> &mdash; запрос начат</li>
			<li><code>progress</code> &mdash; браузер получил очередной пакет данных</li>
			<li><code>abort</code> &mdash; запрос был отменён вызовом <code>xhr.abort()</code></li>
			<li><code>error</code> &mdash; произошла ошибка</li>
			<li><code>load</code> &mdash; запрос был успешно (без ошибок) завершён</li>
			<li><code>loadend</code> &mdash; запрос был прекращён по таймауту</li>
			<li><code>readystatechange</code> &mdash; запрос был завершён (успешно или неуспешно)</li>
		</ul>
	</section>


	<section class="slide">
		<h2 class="shout">Promise и<br />Fetch API</h2>
	</section>

	<section class="slide question">
		<h2>
			<span style="font-size: 85%">Асинхронность в JavaScript</span>
		</h2>
	</section>

	<section class="slide">
		<!--
    прежде чем говорить о промисах и прочей ерунде
    надо рассказать о том что такое callback hell
    или более широкое понятие pyramid of doom.
    Не тот Doom который лучше чем DOM.
    вспомним о том что такое callback-и
    функции могут возвращать результат естественным путем
    функции могут возвращать результат через callback (когда мы работаем с асинхронным кодом)
    callback это функция которую мы передаем в другую функцию чтобы та в свою очередь вызвала
    из-за этой особенности многим трудно понимать код на JS:
    код выполняется не сверху вниз а фиг пойми как
    например на слайде нижнее сообщение выполнится первым
    это сделано не просто так а ради неблокирующих операций IO
    асинхронность в JS это сила а не слабость, но за всё надо платить
    но какой код мы напишем если после первой операции
    нам нужно будет сделать еще одну асинхронную и вывести результат?
    -->
		<h2>Асинхронность в JavaScript</h2>
		<pre class="hljs js">
		<code>http.get('/user', function (err, user) {</code>
		<code>    if (err) {</code>
		<code>        console.error(err);</code>
		<code>        return;</code>
		<code>    }</code>
		<code>    console.log('User is', user);</code>
		<code>});</code>
		<code> </code>
		<code>console.log('Waiting...');</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<!--
    скорей всего мы просто добавим её вызов в наш callback
    финальный console.log вынесем в новый callback
    а что если нам нужен еще один вызов? или if вставить?
    -->
		<h2>Callback Hell</h2>
		<pre class="hljs js">
		<code>http.post('/signup', user, function (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, function (err, resp2) {</code>
		<code>        if (err) { return console.error(err); }</code>
		<code>        http.get(`/photos/${resp2.avatarId}`, function (err, avatar) {</code>
		<code>            if (err) { return console.error(err); }</code>
		<code>            // ... callback hell!</code>
		<code>        });</code>
		<code>    });</code>
		<code>});</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Избавляемся от пирамид</h2>
		<!--
    как только мы осознали что пирамиды это плохо
    хочется от них избавиться
    сделать это можно например так:
    выносим колбеки как отдельные функции
    придумываем адекватные названия
    расположить их при этом можно в порядке выполненения (JS это позволяет)
    или по старинке следуя правилу "не использовать до объявления"
    пирамид больше нет но callback-и остались
    -->
		<pre class="hljs js">
		<code>http.post('/signup', user, <mark>onSignup</mark>);</code>
		<code> </code>
		<code>function onSignup (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, <mark>onLoadUser</mark>);</code>
		<code>}</code>
		<code> </code>
		<code>function onLoadUser (err, resp2) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/photos/${resp2.avatarId}`, <mark>onLoadAvatar</mark>);</code>
		<code>}</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Try, catch</h2>
		<p class="medium-content"></p>
		<pre class="hljs js">
		<code>try {</code>
		<code>    // Выбрасываем исключение вручную</code>
  		<code>    throw 'Ooops!';</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Привет, я ошибка!</code>
		<code>}</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Асинхронные ошибки</h2>
		<pre class="hljs js">
		<code>try {</code>
		<code>    http.get('/user', function (err) {</code>
		<code>        if (err) {</code>
		<code>            throw err;</code>
		<code>        }</code>
		<code>        console.log('User is', user);</code>
		<code>    });</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Не выполнится</code>
		<code>}</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Асинхронные ошибки</h2>
		<pre class="hljs js">
		<code>const callback = function (err) {</code>
		<code>    if (err) {</code>
		<code>        throw err;</code>
		<code>    }</code>
		<code>    console.log('User is', user);</code>
		<code>};</code>
		<code> </code>
		<code>try {</code>
		<code>    http.get('/user', callback);</code>
		<code>} catch (err) {</code>
		<code>    alert(err); // Не выполнится</code>
		<code>}</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<!--
    рассказ про то когда и зачем придумали Promise
    -->
		<h2>Futures или Promises</h2>
		<p class="small-content">Термин <mark>promise</mark> был предложен в 1976 году Дэниэлом Фридманом и Дэвидом Вайзом,
			а Питер Хиббард назвал его <mark>eventual</mark>. Похожая концепция под названием <mark>future</mark> была
			предложена в 1977 году в статье Генри Бейкера и Карла Хьюитта</p>
	</section>


	<section class="slide">
		<h2>Promise</h2>
		<blockquote>
			<p><b>Promise (обещание)</b> &mdash; представляет собой обертку для значения, неизвестного на момент создания
				обещания</p>
		</blockquote>
		<p class="note">Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными:
			вместо конечного результата асинхронного метода возвращается обещание получить результат в некоторый момент в
			будущем</p>
	</section>

	<section class="slide">
		<h2>Promise</h2>
		<blockquote>
			<p><b>Promises (промисы)</b> &mdash; это специальные объекты, которые могут находиться в одном из трёх состояний:
				<ul>
					<li>вначале <strong>pending</strong> («ожидание»)</li>
					<li>затем либо <strong>fulfilled</strong> («выполнено успешно»)</li>
					<li>либо <strong>rejected</strong> («выполнено с ошибкой»)</li>
				</ul>
			</p>
		</blockquote>
		<div style="position:relative;width: 100%; height: 40%;">
			<img class="place" src="promiseInit.png"
				style="transform-origin: center;transform: translate(-50%,-50%) scale(1.6);">
		</div>
	</section>

	<section class="slide">
		<h2>Promise</h2>
		<pre class="hljs js">
		<code>const promise = new Promise(function(resolve, reject) {</code>
		<code>    // Здесь можно выполнять любые действия</code>
		<code> </code>
		<code>    // вызов resolve(result) переведёт промис в состояние <mark>fulfilled</mark></code>
		<code>    // вызов reject(error) переведёт промис в состояние <mark>rejected</mark></code>
		<code>});</code>
		<code> </code>
		<code>// Можно создать сразу "готовый" промис</code>
		<code>const fulfilled = Promise.resolve(result);</code>
		<code>// const fulfilled = new Promise((resolve, _) => resolve(result));</code>
		<code>const rejected = Promise.reject(error);</code>
		<code>// const rejected = new Promise((_, reject) => reject(error));</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Promise</h2>
		<p>Основной способ взаимодействия с промисом это регистрация функций обратного вызова для получения конечного
			результата промиса или сообщения о причине, по которой он не был выполнен. Иными словами, на промисы можно
			навесить два коллбека:</p>
		<ul>
			<li><code>onFulfilled</code> &mdash; срабатывают, когда promise находится в состоянии «выполнен успешно»</li>
			<li><code>onRejected</code> &mdash; срабатывают, когда promise находится в состоянии «выполнен с ошибкой»</li>
		</ul>
	</section>

	<section class="slide">
		<h2>Promise</h2>
		<pre class="hljs js">
		<code>const promise = new Promise( ... );</code>
		<code> </code>
		<code>// Можно навесить их одновременно</code>
		<code>promise.then(onFulfilled, onRejected);</code>
		<code> </code>
		<code>// Можно по отдельности</code>
		<code>// Только обработчик onFulfilled</code>
		<code>promise.then(onFulfilled);</code>
		<code>// Только обработчик onRejected</code>
		<code>promise.then(null, onRejected);</code>
		<code>promise.catch(onRejected); // Или так</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Promise</h2>
		<pre class="hljs js">
		<code>const promise = new Promise(function(resolve, reject) {</code>
		<code>    // do smth</code>
		<code>    resolve('success'); // or</code>
		<code>    // reject(new Error('failure'));</code>
		<code>});</code>
		<code> </code>
		<code>promise</code>
		<code>    <mark>.then</mark>(res => console.log(res))</code>
		<code>    <mark>.catch</mark>(err => console.error(err));</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<!--
    Этот небольшой трюк дарит нам много возможностей
    для организации нашего асинхронного кода
    Перечисляю и рассказываю первые три пункта, на последнем скипаю к след слайду
    -->
		<h2>Какая польза от промисов?</h2>
		<p class="small-content"></p>
		<ul>
			<li>Можно навешивать несколько обработчиков-колбэков</li>
			<li>Можно навесить обработчик-колбэк потом</li>
			<li>Можно передавать промисы в качестве аргументов в другие части системы</li>
			<li>Можно строить цепочки асинхронных вызовов без callback hell</li>
		</ul>
	</section>

	<section class="slide">
		<h2>Добавление нескольких коллбэков</h2>
		<pre class="hljs js">
		<code>// 'cb1 success', 'cb2 success'</code>
		<code>const promise = Promise.resolve('success');</code>
		<code> </code>
		<code>promise.then(res => { console.log('cb1', res); }); // 1</code>
		<code>promise.then(res => { console.log('cb2', res); }); // 2</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Чейнинг промисов</h2>
		<pre class="hljs js">
		<code>// 'value 1', 'value 2', 'value 3'</code>
		<code>const promise = Promise.resolve('value 1');</code>
		<code> </code>
		<code>const p2 = promise</code>
		<code>    .then(res => { console.log(res); return 'value 2'; }) // 1</code>
		<code>    .then(res => { console.log(res); return 'value 3'; }) // 2</code>
		<code>    .then(res => { console.log(res); });                  // 3</code>
		<code> </code>
		<code>p2 === promise // false</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Обработка асинхронных ошибок</h2>
		<pre class="hljs js">
		<code>// 'value 1', 'Error!', 'Error catched!'</code>
		<code>const promise = Promise.resolve('value 1');</code>
		<code> </code>
		<code>promise</code>
		<code>    .then(res => { console.log(res); throw 'Error!'; })             // 1</code>
		<code>    .then(res => { console.log('foo'); })</code>
		<code>    .then(res => { console.log('bar'); })</code>
		<code>    .then(res => { console.log('baz'); })</code>
		<code>    .catch(err => { console.error(err); return 'Error catched!'; }) // 2</code>
		<code>    .then(res => { console.log(res); });                            // 3</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Из промиса можно возвращать<br />промис!</h2>
		<pre class="hljs js">
		<code>// 'foo', 'baz', 'bar', 'foobar'</code>
		<code>const promise1 = Promise.resolve('foo')</code>
		<code>    .then(res => { console.log(res); return 'bar'; });    // foo</code>
		<code> </code>
		<code>const promise2 = Promise.resolve('baz')</code>
		<code>    .then(res => { console.log(res); <mark>return promise1</mark>; })  // baz</code>
		<code>    .then(res => { console.log(res); return 'foobar'; })  // bar</code>
		<code>    .then(res => { console.log(res); });                  // foobar</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Промисификация</h2>
		<blockquote>
			<p>Оборачивание <strong>асинхронного функционала</strong> в функцию, возвращающую промис</p>
		</blockquote>
		<pre class="hljs js">
		<code>function PromiseGet(url) {</code>
		<code>    return new Promise(function (resolve, reject) {</code>
		<code>        http.Get(url, function (err, response) {</code>
		<code>            if (err) { reject(err) }</code>
		<code>            resolve(response);</code>
		<code>        });</code>
		<code>    });</code>
		<code>}</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Callback Hell!</h2>
		<pre class="hljs js">
		<code>http.post('/signup', user, function (err, resp1) {</code>
		<code>    if (err) { return console.error(err); }</code>
		<code>    http.get(`/users/${resp1.id}`, function (err, resp2) {</code>
		<code>        if (err) { return console.error(err); }</code>
		<code>        http.get(`/photos/${resp2.avatarId}`, function (err, avatar) {</code>
		<code>            if (err) { return console.error(err); }</code>
		<code>            // ... callback hell!</code>
		<code>        });</code>
		<code>    });</code>
		<code>});</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2><s>Callback Hell!</s> Красота :)</h2>
		<pre class="hljs js">
		<code>PromisePost('/signup', user)</code>
		<code>    .then(resp1 => PromiseGet(`/users/${resp1.id}`))</code>
		<code>    .then(resp2 => PromiseGet(`/photos/${resp2.avatarId}`))</code>
		<code>    .then(avatar => { ... })</code>
		<code>    .catch(err => console.error(err));</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2><code>Promise.all</code></h2>
		<pre class="hljs js">
		<code>// Делаем что-нибудь асинхронное и важное параллельно</code>
		<code>Promise.all([</code>
		<code>	  PromiseGet('/user/1'),</code>
		<code>	  PromiseGet('/user/2'),</code>
		<code>]).then(function(users) {</code>
		<code>	  // Результатом станет массив из значений всех промисов</code>
		<code>	  users.forEach(function(user, i) {</code>
		<code>	  	  console.log(`User #${i}: ${value}`);</code>
		<code>	  });</code>
		<code>});</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2><code>Promise.race</code></h2>
		<pre class="hljs js">
		<code>// Делаем что-нибудь асинхронное и важное наперегонки!</code>
		<code>Promise.race([</code>
		<code>	  promiseSomething(),</code>
		<code>	  promiseSomethingElse()</code>
		<code>]).then(function(result) {</code>
		<code>	  // Результатом станет значение самого "быстрого" промиса</code>
		<code>	  console.log(`Result: ${value}`);</code>
		<code>});</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2><code>Async/await</code></h2>
		<blockquote>
			<p>«async/await» - Специальный синтаксис для работы с промисами</p>
		</blockquote>
		<pre class="hljs js">
		<code>// Синтаксический сахар</code>
		<code>async function f() {</code>
		<code>  return 1; // return Promise.resolve(1);</code>
		<code>}</code>
		<code>f().then(alert); // 1</code>
		<code> </code>
	</pre>
	</section>



	<section class="slide">
		<h2><code>Async/await</code></h2>
		<blockquote>
			<p> Можно использовать только в асинхронных функциях</p>
		</blockquote>
		<pre class="hljs js">
		<code>async function f() {</code>

		<code>	let promise = new Promise((resolve, reject) => {</code>
		<code>		setTimeout(() => resolve("готово!"), 1000)</code>
		<code>	});</code>
		<code> </code>
		<code>	let result = await promise; // будет ждать, пока промис не выполнится </code>
		<code> </code>
		<code>	alert(result); // "готово!"</code>
		<code>}</code>
		<code>f();</code>
		<code> </code>
	</pre>
	</section>

	<section class="slide">
		<h2>Fetch API</h2>
		<blockquote>
			<p>
				Метод <mark>fetch</mark> &mdash; это <mark>XMLHttpRequest</mark> нового поколения.
				Он предоставляет улучшенный интерфейс для осуществления запросов к серверу:
				как по части возможностей и контроля над происходящим,
				так и по синтаксису, так как построен на <b>промисах</b>
			</p>
		</blockquote>
		<pre class="hljs js">
		<code>// Синтаксис метода fetch:</code>
		<code>const fetchPromise = fetch(url[, options]);</code>
	</pre>
	</section>

	<section class="slide">
		<h2>Fetch API options</h2>
		<ul>
			<li><code>method</code> &mdash; метод запроса</li>
			<li><code>headers</code> &mdash; заголовки запроса (объект)</li>
			<li><code>body</code> &mdash; тело запроса: <code>FormData</code>, <code>Blob</code>, строка и т.п.</li>
			<li><code>mode</code> &mdash; одно из: «same-origin», «no-cors», «cors», указывает, в каком режиме
				кросс-доменности предполагается делать запрос</li>
			<li><code>credentials</code> &mdash; одно из: «omit», «same-origin», «include», указывает, пересылать ли куки и
				заголовки авторизации вместе с запросом</li>
			<li><code>cache</code> &mdash; одно из «default», «no-store», «reload», «no-cache», «force-cache»,
				«only-if-cached», указывает, как кешировать запрос</li>
		</ul>
	</section>

	<section class="slide">
		<h2>Fetch API</h2>
		<pre class="hljs js">
		<code>fetch('/server', {</code>
		<code>	method: 'POST',</code>
		<code>	credentials: 'include',</code>
		<code>	data: JSON.stringify({</code>
		<code>		key: 'value',</code>
		<code>	})</code>
		<code>});</code>
		<code> </code>
	</pre>
	</section>


    <section class="slide">
        <h2 class="shout">Cookies</h2>
    </section>

    <section class="slide question">
        <h2>HTTP is a stateless protocol</h2>
    </section>

    <section class="slide">
        <h2>Cookies</h2>
        <div>
            <blockquote>
                <p class="small-content"><b>Куки (cookies)</b> &mdash; небольшой фрагмент данных, отправленный веб-сервером и
                    хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу
                    соответствующего сайта пересылает этот фрагмент данных веб-серверу в виде HTTP-запроса</p>
            </blockquote>
        </div>
    </section>

    <section class="slide">
        <h2><a href="http://tools.ietf.org/html/rfc2965">Спецификация</a> cookies</h2>
        <p class="small-content"></p>
        <ul lang="ru">
            <li>Браузер должен хранить как минимум 4096 байт кук</li>
            <li>Минимум 20 шт. на домен</li>
            <li>Минимум 300 шт. всего</li>
            <li>Имена <mark>нечувствительны</mark> к регистру</li>
        </ul>
    </section>

    <section class="slide">
        <h2>1 Клиент → Сервер</h2>
        <pre class="hljs http">
			<code>GET / HTTP/1.1</code>
			<code>Host: example.com</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>2 Клиент ← Сервер</h2>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code><mark>Set-Cookie: name=value</mark></code>
			<code>Content-Type: text/html</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>3 Клиент → Сервер</h2>
        <pre class="hljs http">
			<code>GET / HTTP/1.1</code>
			<code>Host: example.com</code>
			<code><mark>Cookie: name=value</mark></code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>4 Клиент ← Сервер</h2>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code><mark>Set-Cookie: name=value2</mark></code>
			<code>Content-Type: text/html</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>Использование</h2>
        <p class="small-content"></p>
        <ul lang="ru">
            <li>Аутентификация пользователей</li>
            <li>Хранение настроек пользователей</li>
            <li>Отслеживание сеанса (сессия)</li>
            <li>Сбор статистики</li>
            <li>Проведение экспериментов</li>
            <li>etc...</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Set-Cookie</h2>
        <pre class="hljs http">
			<code>Set-Cookie: value</code>
			<code>                 [;<span hidden>X:</span> Expires=date]</code>
			<code>                 [;<span hidden>X:</span> Max-Age=age]</code>
			<code>                 [;<span hidden>X:</span> Domain=domain]</code>
			<code>                 [;<span hidden>X:</span> Path=path]</code>
			<code>                 [;<span hidden>X:</span> Secure]</code>
			<code>                 [;<span hidden>X:</span> HttpOnly]</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>Cookie ID</h2>
        <pre class="hljs http">
			<code>Set-Cookie: name=v1; domain=.example.com; path=/</code>
			<code>Set-Cookie: name=v2; domain=www.example.com; path=/</code>
			<code>Set-Cookie: name=v3; domain=.example.com; path=/archive</code>
			<code> </code>
		</pre>
        <pre class="hljs http">
			<code>Cookie: name=v1; name=v2; name=v3</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>JavaScript</h2>
        <p class="small-content"></p>
        <pre class="hljs js">
			<code>document.cookie; /* 'name1=value1' */</code>
			<code class="next">document.cookie = 'name2=value2';</code>
			<code class="next">document.cookie; /* 'name1=value1; name2=value2' */</code>
			<code> </code>
		</pre>
    </section>

    <!-- <section class="slide">
        <h2>Credentials вместе с XHR</h2>
        <p class="small-content"></p>
        <pre class="hljs js">
            <code>const xhr = new XMLHttpRequest();</code>
            <code>xhr.open('GET', '/auth', <mark>true</mark>);</code>
            <code> </code>
            <code>xhr.withCredentials = true; // отправляем cookies</code>
            <code> </code>
            <code>xhr.send();</code>
            <code> </code>
        </pre>
    </section> -->

    <section class="slide">
        <h2>Итого: авторизация через куки</h2>
        <ul lang="ru">
            <li><strong>Клиент не работает с куками</strong></li>
            <li>При запуске приложения, отправляем запрос за текущим пользователем</li>
            <li>Если <mark>на бекенд</mark> приходит запрос без кук &mdash; значит пользователь не авторизован, возвращаем 401
            </li>
            <li>Если <mark>на бекенд</mark> приходит запрос c куками &mdash; значит пользователь авторизован, возвращаем 200
            </li>
            <li>На <mark>клиенте</mark>, в зависимости от ответа сервера, рисуем либо профиль пользователя, либо форму
                авторизации</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Same Origin Policy</h2>
        <blockquote>
            <p class="medium-content"><b>Правило ограничения домена (Same Origin Policy &mdash; «Принцип одинакового
                источника» a.k.a. «Политика единого источника»)</b> &mdash; это важная концепция безопасности и работы
                web-приложений. Она призвана
                <mark>ограничивать возможности</mark> пользовательских сценариев из определённого источника по доступу к
                ресурсам и информации из других
                источников</p>
        </blockquote>
        <p class="note"><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy"
                           target="_blank">Подробнее</a></p>
    </section>

    <section class="slide">
        <h2>Same Origin Policy</h2>
        <p>Вводится понятие
            <mark>источника</mark>
            (адрес в интернете, откуда был загружен&nbsp;ресурс). Два URL считаются имеющим один источник («same origin»),
            если у
            них
            <mark>одинаковый протокол, домен и порт</mark>
        </p>
        <p>У этих ресурсов одинаковые источники:</p>
        <ul>
            <li><code>http://site.com</code></li>
            <li><code>http://site.com/</code></li>
            <li><code>http://site.com/my/page.html</code></li>
        </ul>
    </section>

    <section class="slide">
        <h2>Same Origin Policy</h2>
        <p>У этих ресурсов <strong>разные</strong> источники:</p>
        <ul>
            <li><code>http://site.com</code></li>
            <li><code>http://<strong>www</strong>.site.com</code> (другой домен)</li>
            <li><code>http://site.<strong>org</strong></code> (другой домен)</li>
            <li><code><strong>https</strong>://site.com</code> (другой протокол)</li>
            <li><code>http://site.com:<strong>8080</strong></code> (другой порт)</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Типы взаимодействия с ресурсами</h2>
        <p>Любой способ взаимодействия с ресурсами в web-приложениях можно отнести к одной из трёх категорий:</p>
        <ul>
            <li><mark><strong>"Запись" в ресурсы</strong></mark> &mdash; например: переходы по ссылкам, редиректы, сабмит
                форм, отправка запросов</li>
            <li><mark><strong>"Встраивание" ресурсов в другие ресурсы</strong></mark>:
                <ul>
                    <li>JavaScript with <code>&lt;script src="...">&lt;/script></code></li>
                    <li>CSS with <code>&lt;link rel="stylesheet" href="..."></code></li>
                    <li>Images with <code>&lt;img></code>, media files with <code>&lt;video></code> and <code>&lt;audio></code>
                    </li>
                    <li>Plug-ins with <code>&lt;object></code>, <code>&lt;embed></code> and <code>&lt;applet></code></li>
                </ul>
            </li>
            <li><mark><strong>"Чтение" из других ресурсов</strong></mark> &mdash; например: чтение ответов на запросы,
                получение доступа к содержимому встроенного ресурса...</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Same Origin Policy</h2>
        <p class="small-content"></p>
        <ul>
            <li>Cross Origin "Запись" в ресурсы обычно разрешается (<em>за некоторыми исключениями, о них чуть позже</em>)
            </li>
            <li>Cross Origin "Встраивание" ресурсов обычно разрешается</li>
            <li>Cross Origin "Чтение" из других ресурсов по-умолчанию запрещено</li>
        </ul>
    </section>

    <section class="slide question">
        <h2><span style="font-size: 80%; display: inline-block;">Как законно обойти ограничения Same Origin Policy?</span>
        </h2>
    </section>

    <section class="slide">
        <h2>Архитектура приложений</h2>
        <div style="position:relative;width: 100%; height: 75%;">
            <img class="place" src="arch.png" style="transform-origin: center;transform: translate(-50.45%,-51%) scale(.55);">
        </div>
    </section>

    <section class="slide">
        <h2>HTTP access control (CORS)</h2>
        <p class="medium-content"></p>
        <blockquote>
            <p class="small-content"><b>Cross-Origin Resource Sharing (CORS) standard</b> &mdash; спецификация,
                позволяющая обойти ограничения, которые Same Origin Policy накладывает на кросс-доменные запросы</p>
        </blockquote>
        <p class="note"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" target="_blank">Подробнее</a></p>
    </section>

    <section class="slide">
        <h2>Cross Origin HTTP-запросы (
            <mark>XHR</mark>
            )
        </h2>
        <pre class="hljs js">
		<code>// Находимся на https://evil.com/</code>
		<code>const xhr = new XMLHttpRequest();</code>
		<code>xhr.open('GET', <mark>'https://e.mail.ru/messages/inbox/'</mark>, false);</code>
		<code>xhr.send();</code>
		<code> </code>
		<code>console.log(xhr.responseText)</code>
		<code> </code>
	</pre>
    </section>

    <section class="slide">
        <h2>Запросы делятся на два типа</h2>
        <p>Простыми считаются запросы, если они удовлетворяют следующим двум условиям:</p>
        <ul>
            <li>Простой метод: GET, POST или HEAD</li>
            <li>Простые заголовки &mdash; только из списка:
                <ul>
                    <li><code>Accept</code></li>
                    <li><code>Accept-Language</code></li>
                    <li><code>Content-Language</code></li>
                    <li><code>Content-Type</code>
                        <ul>
                            <li><code>application/x-www-form-urlencoded</code></li>
                            <li><code>multipart/form-data</code></li>
                            <li><code>text/plain</code></li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </section>

    <section class="slide">
        <h2>CORS для простых запросов</h2>
        <pre class="hljs http">
			<code>GET /data HTTP/1.1</code>
			<code>Host: e.mail.ru</code>
			<code>Origin: http://frontend.tech-mail.ru</code>
			<code> </code>
		</pre>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code><mark>Access-Control-Allow-Origin:</mark> http://frontend.tech-mail.ru</code>
			<code>// Access-Control-Allow-Origin: *</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>CORS для простых запросов:<br />дополнительные заголовки</h2>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: http://frontend.tech-mail.ru</code>
			<code>...</code>
			<code>X-UID: 42</code>
			<code>X-Secret: 2c9de507f2c54aa1</code>
			<code><mark>Access-Control-Expose-Headers:</mark> X-Uid, X-Authentication</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>CORS для простых запросов:<br />данные авторизации</h2>
        <pre class="hljs js">
			<code>const xhr = new XMLHttpRequest();</code>
			<code>xhr.<mark>withCredentials</mark> = true;</code>
			<code>xhr.open('GET', 'https://e.mail.ru/messages/inbox/', false);</code>
			<code> </code>
		</pre>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/html; charset=UTF-8</code>
			<code>Access-Control-Allow-Origin: <mark>domain</mark> // '*' запрещено</code>
			<code><mark>Access-Control-Allow-Credentials:</mark> true</code>
			<code> </code>
		</pre>
    </section>

    <section class="slide">
        <h2>Запросы делятся на два типа</h2>
        <p class="small-content">Остальные запросы считаются
            <mark>"непростыми"</mark>
            , и при отправке таких запросов необходимо понять, согласен ли сервер на обработку таких запросов. Эти запросы
            всегда отсылаются со специальным заголовком <code>Origin</code></p>
    </section>

    <section class="slide">
        <h2>"Непростые" запросы</h2>
        <p>При отправке "непростого" запроса, браузер сделает на самом деле <strong>два</strong> HTTP-запроса.
        <ul>
            <li>«Предзапрос» (английский термин «preflight») OPTIONS. Cодержит название желаемого метода в заголовке
                <code>Access-Control-Request-Method</code>,
                а если добавлены особые заголовки, то и их тоже &mdash; в <code>Access-Control-Request-Headers</code>.
            </li>
            <li>Основной HTTP-запрос с заголовком <code>Origin</code></li>
        </ul>
    </section>

    <section class="slide">
        <h2>"Непростые" запросы</h2>
        <p>Ответ на предзапрос может содержать следующие заголовки</p>
        <pre class="hljs http">
			<code>HTTP/1.1 200 OK</code>
			<code>Content-Type: text/plain</code>
			<code><mark>Access-Control-Allow-Methods:</mark> DELETE, PUT, HEAD, OPTIONS, GET, POST</code>
			<code><mark>Access-Control-Allow-Headers:</mark> Content-Type, User-Agent ...</code>
			<code>         ... X-Requested-With, If-Modified-Since, Cache-Control</code>
			<code><mark>Access-Control-Max-Age:</mark> 86400</code>
			<code> </code>
		</pre>
    </section>


    <!--закончили с Безопасностью-->


    <section class="slide">
        <h2 class="shout">Работа с API</h2>
    </section>

    <section class="slide">
        <h2>Что есть
            <mark>API</mark>
        </h2>
        <blockquote>
            <p class="medium-content"><b>API (application programming interface, интерфейс программирования приложений)</b>
                &mdash; набор готовых классов, процедур, функций, структур и констант, предоставляемых приложением
                (библиотекой, сервисом) или операционной системой для использования во внешних программных продуктах.
                Используется программистами при написании всевозможных приложений</p>
        </blockquote>
    </section>

    <section class="slide">
        <h2>Что есть
            <mark>API</mark>
        </h2>
        <p>API определяет
            <mark>функциональность</mark>
            , которую предоставляет программа (модуль, библиотека), при этом API позволяет абстрагироваться от того, как
            именно эта функциональность реализована
        </p>
        <p><b>Web API</b> &mdash; используется в веб-разработке, как правило, определённый набор HTTP-запросов, а также
            определение
            <mark>структуры</mark>
            HTTP-ответов, для выражения которых используют XML или JSON форматы
        </p>
    </section>

    <section class="slide">
        <h2>Сема́нтика</h2>
        <blockquote>
            <p><b>Сема́нтика</b> &mdash; раздел лингвистики, изучающий смысловое значение единиц языка</p>
        </blockquote>
        <p><br />
            &ndash; <em>Работодатель:</em> Назовите вашу главную слабость <br />
            &ndash; <em>Кандидат:</em> Я даю
            <mark>семантически</mark>
            корректные, но практически неприменимые ответы на вопросы <br />
            &ndash; <em>Работодатель:</em> Могли бы вы привести пример? <br />
            &ndash; <em>Кандидат:</em> Да, мог бы
        </p>
    </section>

    <section class="slide">
        <h2>CRUD</h2>
        <blockquote>
            <p><b>CRUD (create, read, update, delete)</b> &mdash; акроним, обозначающий четыре базовые функции, используемые
                при работе с персистентными хранилищами данных, описывает семантику методов HTTP</p>
        </blockquote>
        <ul>
            <li>GET (чтение данных)</li>
            <li>POST (создание данных)</li>
            <li>PUT (полное обновление данных) или PATCH (частичное обновление данных)</li>
            <li>DELETE (удаление данных)</li>
            <li>HEAD запрашивает ресурс так же, как и GET, но без тела ответа</li>
            <li>OPTIONS используется для описания параметров соединения с ресурсом</li>
        </ul>
    </section>

    <section class="slide">
        <h2>REST</h2>
        <blockquote>
            <p><b>REST (в применении к именованию ресурсов)</b> &mdash; набор методик и практик, которые используются для
                именования ресурсов, с которыми работает система</p>
        </blockquote>
        <p>Все типы ресурсов делятся на две категории:</p>
        <ul>
            <li>
                <mark>коллекции ресурсов</mark> &mdash; имеют имя
            </li>
            <li>
                <mark>отдельные представители</mark> &mdash; принадлежат к какой-то коллекции и имеют идентификатор, чтобы
                отличать различных представителей коллекции друг от друга
            </li>
        </ul>
    </section>

    <section class="slide">
        <h2>REST</h2>
        <p>Коллекция книг (books):</p>
        <ul>
            <li>Вся коллекция получает URI <code>/books</code></li>
            <li>Идентификатор книги &mdash; её ISBN. Отдельные книги:
                <ul>
                    <li><code>/books/2-266-11156-6</code></li>
                    <li><code>/books/3-720-55486-7</code></li>
                    <li><code>/books/1-054-55901-2</code></li>
                </ul>
            </li>
        </ul>
    </section>

    <section class="slide">
        <h2>REST</h2>
        <p>Коллекция пользователей (users):</p>
        <ul>
            <li>Вся коллекция получает URI <code>/users</code></li>
            <li>Идентификатор пользователя &mdash; его ID. Отдельные пользователи:
                <ul>
                    <li><code>/users/id2</code></li>
                    <li><code>/users/id432</code></li>
                    <li><code>/users/id1211177181</code></li>
                </ul>
            </li>
        </ul>
    </section>

    <section class="slide">
        <h2>REST + CRUD = семантическое API</h2>
        <pre class="hljs http">
		<code>Получение всех книг</code>
		<code>GET /books HTTP/1.1</code>
		<code>Host: awesome.com</code>
		<code> </code>
		<code>Получение конкретной книги</code>
		<code>GET /books/3-720-55486-7 HTTP/1.1</code>
		<code>Host: awesome.com</code>
		<code> </code>
		<code>Удаление конкретной книги</code>
		<code>DELETE /books/3-720-55486-7 HTTP/1.1</code>
		<code>Host: awesome.com</code>
		<code> </code>
	</pre>
    </section>

    <section class="slide">
        <h2>Документирование API</h2>
        <p class="small-content"></p>
        <ul>
            <li><a href="http://swagger.io/" target="_blank">swagger</a></li>
            <li><a href="https://apiary.io/" target="_blank">apiary</a></li>
            <li><a href="https://apiblueprint.org/" target="_blank">apiblueprint</a></li>
            <li>Ваши варианты ;)</li>
        </ul>
    </section>

    <section class="slide">
        <h2>Другие способы организации API</h2>
        <p class="small-content"></p>
        <ul>
            <li><a href="https://ru.wikipedia.org/wiki/JSON-RPC" target="_blank">JSON-RPC</a></li>
            <li><a href="https://habr.com/post/326986/" target="_blank">GraphQL</a></li>
            <li>Ваши варианты ;)</li>
        </ul>
    </section>


	<section class="slide">
		<h2 class="shout">Всем спасибо!</h2>
	</section>

	<div class="progress"></div>
	<script src="/lib/shower/shower.min.js"></script>
	<script src="/lib/hljs/highlight.pack.js"></script>
	<script>
		hljs.initHighlightingOnLoad();
	</script>
</body>

</html>
